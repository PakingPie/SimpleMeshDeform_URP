// SDFGenerator.compute
#pragma kernel InitializeSDF
#pragma kernel MeshToSDF
#pragma kernel FinalizeSDF

// Output SDF volume
RWTexture3D<float> _SDFVolume;

// Input mesh data (from LinearBVH)
struct LinearBVHNode
{
    float3 boundsMin;
    int leftOrTriangleOffset;
    float3 boundsMax;
    int triangleCount;
};

struct GPUTriangle
{
    float3 v0;
    float pad0;
    float3 v1;
    float pad1;
    float3 v2;
    float pad2;
};

StructuredBuffer<LinearBVHNode> _BVHNodes;
StructuredBuffer<GPUTriangle> _Triangles;

// Parameters
float3 _VolumeMin;
float3 _VolumeMax;
int3 _VolumeResolution;
int _BVHNodeCount;
float _InitialValue;
float _NarrowBandWidth;

// Stack for BVH traversal (max depth 32)
#define MAX_STACK_DEPTH 32

float3 VoxelToWorld(int3 voxel)
{
    float3 t = (float3(voxel) + 0.5) / float3(_VolumeResolution);
    return lerp(_VolumeMin, _VolumeMax, t);
}

float PointToTriangleDistance(float3 p, float3 a, float3 b, float3 c)
{
    float3 ab = b - a;
    float3 ac = c - a;
    float3 ap = p - a;
    
    float d1 = dot(ab, ap);
    float d2 = dot(ac, ap);
    if (d1 <= 0.0 && d2 <= 0.0)
        return length(p - a);
    
    float3 bp = p - b;
    float d3 = dot(ab, bp);
    float d4 = dot(ac, bp);
    if (d3 >= 0.0 && d4 <= d3)
        return length(p - b);
    
    float vc = d1 * d4 - d3 * d2;
    if (vc <= 0.0 && d1 >= 0.0 && d3 <= 0.0)
    {
        float v = d1 / (d1 - d3);
        return length(p - (a + v * ab));
    }
    
    float3 cp = p - c;
    float d5 = dot(ab, cp);
    float d6 = dot(ac, cp);
    if (d6 >= 0.0 && d5 <= d6)
        return length(p - c);
    
    float vb = d5 * d2 - d1 * d6;
    if (vb <= 0.0 && d2 >= 0.0 && d6 <= 0.0)
    {
        float w = d2 / (d2 - d6);
        return length(p - (a + w * ac));
    }
    
    float va = d3 * d6 - d5 * d4;
    if (va <= 0.0 && (d4 - d3) >= 0.0 && (d5 - d6) >= 0.0)
    {
        float w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
        return length(p - (b + w * (c - b)));
    }
    
    float denom = 1.0 / (va + vb + vc);
    float v2 = vb * denom;
    float w2 = vc * denom;
    float3 closest = a + ab * v2 + ac * w2;
    return length(p - closest);
}

float3 ClosestPointOnTriangle(float3 p, float3 a, float3 b, float3 c)
{
    float3 ab = b - a;
    float3 ac = c - a;
    float3 ap = p - a;
    
    float d1 = dot(ab, ap);
    float d2 = dot(ac, ap);
    if (d1 <= 0.0 && d2 <= 0.0)
        return a;
    
    float3 bp = p - b;
    float d3 = dot(ab, bp);
    float d4 = dot(ac, bp);
    if (d3 >= 0.0 && d4 <= d3)
        return b;
    
    float vc = d1 * d4 - d3 * d2;
    if (vc <= 0.0 && d1 >= 0.0 && d3 <= 0.0)
    {
        float v = d1 / (d1 - d3);
        return a + v * ab;
    }
    
    float3 cp = p - c;
    float d5 = dot(ab, cp);
    float d6 = dot(ac, cp);
    if (d6 >= 0.0 && d5 <= d6)
        return c;
    
    float vb = d5 * d2 - d1 * d6;
    if (vb <= 0.0 && d2 >= 0.0 && d6 <= 0.0)
    {
        float w = d2 / (d2 - d6);
        return a + w * ac;
    }
    
    float va = d3 * d6 - d5 * d4;
    if (va <= 0.0 && (d4 - d3) >= 0.0 && (d5 - d6) >= 0.0)
    {
        float w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
        return b + w * (c - b);
    }
    
    float denom = 1.0 / (va + vb + vc);
    float v2 = vb * denom;
    float w2 = vc * denom;
    return a + ab * v2 + ac * w2;
}

float DistanceToBounds(float3 p, float3 boundsMin, float3 boundsMax)
{
    float3 closest = clamp(p, boundsMin, boundsMax);
    return length(p - closest);
}

float QueryBVH(float3 point, out float3 closestPoint)
{
    float minDist = 1e10;
    closestPoint = point;
    
    if (_BVHNodeCount == 0)
        return minDist;
    
    // Stack-based BVH traversal
    int stack[MAX_STACK_DEPTH];
    int stackPtr = 0;
    stack[stackPtr++] = 0; // Root node
    
    while (stackPtr > 0)
    {
        int nodeIdx = stack[--stackPtr];
        LinearBVHNode node = _BVHNodes[nodeIdx];
        
        // Check bounds distance
        float boundsDist = DistanceToBounds(point, node.boundsMin, node.boundsMax);
        if (boundsDist >= minDist)
            continue;
        
        if (node.triangleCount > 0)
        {
            // Leaf node - check triangles
            for (int i = 0; i < node.triangleCount; i++)
            {
                GPUTriangle tri = _Triangles[node.leftOrTriangleOffset + i];
                float3 cp = ClosestPointOnTriangle(point, tri.v0, tri.v1, tri.v2);
                float dist = length(point - cp);
                
                if (dist < minDist)
                {
                    minDist = dist;
                    closestPoint = cp;
                }
            }
        }
        else
        {
            // Internal node - push children
            int leftIdx = node.leftOrTriangleOffset;
            int rightIdx = leftIdx + 1;
            
            // Push farther node first (so closer is processed first)
            float leftDist = DistanceToBounds(point, _BVHNodes[leftIdx].boundsMin, _BVHNodes[leftIdx].boundsMax);
            float rightDist = DistanceToBounds(point, _BVHNodes[rightIdx].boundsMin, _BVHNodes[rightIdx].boundsMax);
            
            if (stackPtr < MAX_STACK_DEPTH - 1)
            {
                if (leftDist < rightDist)
                {
                    if (rightDist < minDist)
                        stack[stackPtr++] = rightIdx;
                    if (leftDist < minDist)
                        stack[stackPtr++] = leftIdx;
                }
                else
                {
                    if (leftDist < minDist)
                        stack[stackPtr++] = leftIdx;
                    if (rightDist < minDist)
                        stack[stackPtr++] = rightIdx;
                }
            }
        }
    }
    
    return minDist;
}

// Determine sign using ray casting (odd = inside)
float DetermineSign(float3 point, float3 closestPoint)
{
    // Simple approach: use winding number or ray cast
    // For now, use closest triangle normal
    // This assumes we store normals or can compute them
    
    // Approximate: if we can't determine, use distance from center
    float3 center = (_VolumeMin + _VolumeMax) * 0.5;
    float3 toPoint = normalize(point - closestPoint);
    
    // Cast rays in multiple directions and count intersections
    // For simplicity, assume outside for now (positive SDF)
    // A proper implementation would use ray casting through BVH
    
    return 1.0; // Positive = outside
}

[numthreads(8, 8, 8)]
void InitializeSDF(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_VolumeResolution.x ||
        id.y >= (uint)_VolumeResolution.y ||
        id.z >= (uint)_VolumeResolution.z)
        return;
    
    _SDFVolume[id] = _InitialValue;
}

[numthreads(8, 8, 8)]
void MeshToSDF(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_VolumeResolution.x ||
        id.y >= (uint)_VolumeResolution.y ||
        id.z >= (uint)_VolumeResolution.z)
        return;
    
    float3 worldPos = VoxelToWorld(int3(id));
    float3 closestPoint;
    float distance = QueryBVH(worldPos, closestPoint);
    
    // Apply narrow band optimization - only compute accurate SDF near surface
    if (distance > _NarrowBandWidth)
    {
        _SDFVolume[id] = _NarrowBandWidth;
        return;
    }
    
    // Determine sign (inside = negative, outside = positive)
    // For closed meshes, we need proper inside/outside detection
    float sign = DetermineSign(worldPos, closestPoint);
    
    _SDFVolume[id] = distance * sign;
}

[numthreads(8, 8, 8)]
void FinalizeSDF(uint3 id : SV_DispatchThreadID)
{
    // Post-processing kernel for smoothing or fixing SDF issues
    if (id.x >= (uint)_VolumeResolution.x ||
        id.y >= (uint)_VolumeResolution.y ||
        id.z >= (uint)_VolumeResolution.z)
        return;
    
    // Currently a pass-through, can add Gaussian smoothing if needed
}