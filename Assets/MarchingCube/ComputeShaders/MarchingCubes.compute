// MarchingCubes.compute
#pragma kernel ClearCounters
#pragma kernel GenerateVertices
#pragma kernel BuildTriangles

#include "./MarchTables.compute"

// SDF volume texture
Texture3D<float> _SDFVolume;
SamplerState sampler_SDFVolume;

// Output buffers
RWStructuredBuffer<float3> _Vertices;
RWStructuredBuffer<float3> _Normals;
RWStructuredBuffer<int> _Triangles;
RWStructuredBuffer<int> _Counter; // [0] = vertex count, [1] = triangle count

// Parameters
float3 _VolumeMin;
float3 _VolumeMax;
int3 _VolumeResolution;
float _IsoLevel;

// Corner offsets for a cube (standard Marching Cubes convention)
// Bottom face (Y=0): 0,1,2,3 | Top face (Y=1): 4,5,6,7
static const int3 cornerOffsets[8] = {
    int3(0, 0, 0),  // 0
    int3(1, 0, 0),  // 1
    int3(1, 1, 0),  // 2
    int3(0, 1, 0),  // 3
    int3(0, 0, 1),  // 4
    int3(1, 0, 1),  // 5
    int3(1, 1, 1),  // 6
    int3(0, 1, 1)   // 7
};

// Edge to corner mapping (standard Marching Cubes convention)
// Edges 0-3: bottom face, Edges 4-7: top face, Edges 8-11: vertical
static const int2 edgeToCorners[12] = {
    int2(0, 1),  // Edge 0: bottom front
    int2(1, 2),  // Edge 1: bottom right
    int2(2, 3),  // Edge 2: bottom back
    int2(3, 0),  // Edge 3: bottom left
    int2(4, 5),  // Edge 4: top front
    int2(5, 6),  // Edge 5: top right
    int2(6, 7),  // Edge 6: top back
    int2(7, 4),  // Edge 7: top left
    int2(0, 4),  // Edge 8: vertical front-left
    int2(1, 5),  // Edge 9: vertical front-right
    int2(2, 6),  // Edge 10: vertical back-right
    int2(3, 7)   // Edge 11: vertical back-left
};

float SampleSDF(int3 coord)
{
    float3 uvw = (float3(coord) + 0.5) / float3(_VolumeResolution);
    return _SDFVolume.SampleLevel(sampler_SDFVolume, uvw, 0);
}

float3 CoordToWorld(int3 coord)
{
    float3 t = float3(coord) / float3(_VolumeResolution - 1);
    return lerp(_VolumeMin, _VolumeMax, t);
}

float3 InterpolateEdge(float3 p1, float3 p2, float v1, float v2)
{
    if (abs(v2 - v1) < 0.00001)
        return (p1 + p2) * 0.5;
    
    float t = (_IsoLevel - v1) / (v2 - v1);
    t = saturate(t);
    return lerp(p1, p2, t);
}

float3 CalculateNormal(int3 coord)
{
    float dx = SampleSDF(coord + int3(1, 0, 0)) - SampleSDF(coord - int3(1, 0, 0));
    float dy = SampleSDF(coord + int3(0, 1, 0)) - SampleSDF(coord - int3(0, 1, 0));
    float dz = SampleSDF(coord + int3(0, 0, 1)) - SampleSDF(coord - int3(0, 0, 1));
    
    float3 normal = normalize(float3(dx, dy, dz));
    return -normal; // Flip for correct orientation (inside = negative SDF)
}

float3 CalculateNormalAtPoint(float3 worldPos)
{
    float3 uvw = (worldPos - _VolumeMin) / (_VolumeMax - _VolumeMin);
    float3 texelSize = 1.0 / float3(_VolumeResolution);
    
    float dx = _SDFVolume.SampleLevel(sampler_SDFVolume, uvw + float3(texelSize.x, 0, 0), 0) -
               _SDFVolume.SampleLevel(sampler_SDFVolume, uvw - float3(texelSize.x, 0, 0), 0);
    float dy = _SDFVolume.SampleLevel(sampler_SDFVolume, uvw + float3(0, texelSize.y, 0), 0) -
               _SDFVolume.SampleLevel(sampler_SDFVolume, uvw - float3(0, texelSize.y, 0), 0);
    float dz = _SDFVolume.SampleLevel(sampler_SDFVolume, uvw + float3(0, 0, texelSize.z), 0) -
               _SDFVolume.SampleLevel(sampler_SDFVolume, uvw - float3(0, 0, texelSize.z), 0);
    
    return -normalize(float3(dx, dy, dz));
}

[numthreads(1, 1, 1)]
void ClearCounters(uint3 id : SV_DispatchThreadID)
{
    _Counter[0] = 0; // Vertex count
    _Counter[1] = 0; // Triangle count
}

[numthreads(8, 8, 8)]
void GenerateVertices(uint3 id : SV_DispatchThreadID)
{
    // Check bounds (we need one less in each dimension for cubes)
    if (id.x >= (uint)(_VolumeResolution.x - 1) ||
        id.y >= (uint)(_VolumeResolution.y - 1) ||
        id.z >= (uint)(_VolumeResolution.z - 1))
        return;
    
    int3 baseCoord = int3(id);
    
    // Sample all 8 corners
    float cornerValues[8];
    float3 cornerPositions[8];
    
    for (int i = 0; i < 8; i++)
    {
        int3 coord = baseCoord + cornerOffsets[i];
        cornerValues[i] = SampleSDF(coord);
        cornerPositions[i] = CoordToWorld(coord);
    }
    
    // Calculate cube index
    int cubeIndex = 0;
    for (int j = 0; j < 8; j++)
    {
        if (cornerValues[j] < _IsoLevel)
            cubeIndex |= (1 << j);
    }
    
    // Skip if fully inside or outside
    if (cubeIndex == 0 || cubeIndex == 255)
        return;
    
    // Get edge flags
    int edgeFlags = edgeTable[cubeIndex];
    if (edgeFlags == 0)
        return;
    
    // Calculate edge vertices
    float3 edgeVertices[12];
    
    for (int e = 0; e < 12; e++)
    {
        if ((edgeFlags & (1 << e)) != 0)
        {
            int c1 = edgeToCorners[e].x;
            int c2 = edgeToCorners[e].y;
            edgeVertices[e] = InterpolateEdge(
                cornerPositions[c1], cornerPositions[c2],
                cornerValues[c1], cornerValues[c2]
            );
        }
    }
    
    // Generate triangles
    int tableOffset = cubeIndex * 16;
    
    for (int t = 0; t < 15; t += 3)
    {
        int e0 = triangleTable[tableOffset + t];
        if (e0 == -1)
            break;
        
        int e1 = triangleTable[tableOffset + t + 1];
        int e2 = triangleTable[tableOffset + t + 2];
        
        float3 v0 = edgeVertices[e0];
        float3 v1 = edgeVertices[e1];
        float3 v2 = edgeVertices[e2];
        
        // Allocate vertices (3 per triangle for now, can optimize later with indexing)
        int vertexStart;
        InterlockedAdd(_Counter[0], 3, vertexStart);
        
        // Check buffer bounds
        uint maxVertices, stride;
        _Vertices.GetDimensions(maxVertices, stride);
        if ((uint)(vertexStart + 2) >= maxVertices)
            return;
        
        _Vertices[vertexStart] = v0;
        _Vertices[vertexStart + 1] = v1;
        _Vertices[vertexStart + 2] = v2;
        
        _Normals[vertexStart] = CalculateNormalAtPoint(v0);
        _Normals[vertexStart + 1] = CalculateNormalAtPoint(v1);
        _Normals[vertexStart + 2] = CalculateNormalAtPoint(v2);
        
        // Allocate triangle
        int triStart;
        InterlockedAdd(_Counter[1], 3, triStart);
        
        _Triangles[triStart] = vertexStart;
        _Triangles[triStart + 1] = vertexStart + 1;
        _Triangles[triStart + 2] = vertexStart + 2;
    }
}

[numthreads(64, 1, 1)]
void BuildTriangles(uint3 id : SV_DispatchThreadID)
{
    // NOTE: Triangle generation is already handled in GenerateVertices kernel.
    // This kernel is reserved for optional post-processing if needed:
    // - Vertex welding/deduplication
    // - Normal smoothing
    // - UV generation
}