// SDFGenerator.compute
#pragma kernel InitializeSDF
#pragma kernel MeshToSDF
#pragma kernel FinalizeSDF

// Output SDF volume
RWTexture3D<float> _SDFVolume;

// Input mesh data (from LinearBVH)
struct LinearBVHNode
{
    float3 boundsMin;
    int leftOrTriangleOffset;
    float3 boundsMax;
    int triangleCount;
};

struct GPUTriangle
{
    float3 v0;
    float pad0;
    float3 v1;
    float pad1;
    float3 v2;
    float pad2;
};

StructuredBuffer<LinearBVHNode> _BVHNodes;
StructuredBuffer<GPUTriangle> _Triangles;

// Parameters
float3 _VolumeMin;
float3 _VolumeMax;
int3 _VolumeResolution;
int _BVHNodeCount;
float _InitialValue;
float _NarrowBandWidth;

// Stack for BVH traversal (max depth 32)
#define MAX_STACK_DEPTH 32

float3 VoxelToWorld(int3 voxel)
{
    float3 t = (float3(voxel) + 0.5) / float3(_VolumeResolution);
    return lerp(_VolumeMin, _VolumeMax, t);
}

float PointToTriangleDistance(float3 p, float3 a, float3 b, float3 c)
{
    float3 ab = b - a;
    float3 ac = c - a;
    float3 ap = p - a;
    
    float d1 = dot(ab, ap);
    float d2 = dot(ac, ap);
    if (d1 <= 0.0 && d2 <= 0.0)
    return length(p - a);
    
    float3 bp = p - b;
    float d3 = dot(ab, bp);
    float d4 = dot(ac, bp);
    if (d3 >= 0.0 && d4 <= d3)
    return length(p - b);
    
    float vc = d1 * d4 - d3 * d2;
    if (vc <= 0.0 && d1 >= 0.0 && d3 <= 0.0)
    {
        float v = d1 / (d1 - d3);
        return length(p - (a + v * ab));
    }
    
    float3 cp = p - c;
    float d5 = dot(ab, cp);
    float d6 = dot(ac, cp);
    if (d6 >= 0.0 && d5 <= d6)
    return length(p - c);
    
    float vb = d5 * d2 - d1 * d6;
    if (vb <= 0.0 && d2 >= 0.0 && d6 <= 0.0)
    {
        float w = d2 / (d2 - d6);
        return length(p - (a + w * ac));
    }
    
    float va = d3 * d6 - d5 * d4;
    if (va <= 0.0 && (d4 - d3) >= 0.0 && (d5 - d6) >= 0.0)
    {
        float w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
        return length(p - (b + w * (c - b)));
    }
    
    float denom = 1.0 / (va + vb + vc);
    float v2 = vb * denom;
    float w2 = vc * denom;
    float3 closest = a + ab * v2 + ac * w2;
    return length(p - closest);
}

float3 ClosestPointOnTriangle(float3 p, float3 a, float3 b, float3 c)
{
    float3 ab = b - a;
    float3 ac = c - a;
    float3 ap = p - a;
    
    float d1 = dot(ab, ap);
    float d2 = dot(ac, ap);
    if (d1 <= 0.0 && d2 <= 0.0)
    return a;
    
    float3 bp = p - b;
    float d3 = dot(ab, bp);
    float d4 = dot(ac, bp);
    if (d3 >= 0.0 && d4 <= d3)
    return b;
    
    float vc = d1 * d4 - d3 * d2;
    if (vc <= 0.0 && d1 >= 0.0 && d3 <= 0.0)
    {
        float v = d1 / (d1 - d3);
        return a + v * ab;
    }
    
    float3 cp = p - c;
    float d5 = dot(ab, cp);
    float d6 = dot(ac, cp);
    if (d6 >= 0.0 && d5 <= d6)
    return c;
    
    float vb = d5 * d2 - d1 * d6;
    if (vb <= 0.0 && d2 >= 0.0 && d6 <= 0.0)
    {
        float w = d2 / (d2 - d6);
        return a + w * ac;
    }
    
    float va = d3 * d6 - d5 * d4;
    if (va <= 0.0 && (d4 - d3) >= 0.0 && (d5 - d6) >= 0.0)
    {
        float w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
        return b + w * (c - b);
    }
    
    float denom = 1.0 / (va + vb + vc);
    float v2 = vb * denom;
    float w2 = vc * denom;
    return a + ab * v2 + ac * w2;
}

float DistanceToBounds(float3 p, float3 boundsMin, float3 boundsMax)
{
    float3 closest = clamp(p, boundsMin, boundsMax);
    return length(p - closest);
}

float QueryBVH(float3 vertex, out float3 closestPoint)
{
    float minDist = 1e10;
    closestPoint = vertex;
    
    if (_BVHNodeCount == 0)
    return minDist;
    
    // Stack-based BVH traversal
    int stack[MAX_STACK_DEPTH];
    int stackPtr = 0;
    stack[stackPtr++] = 0; // Root node
    
    while (stackPtr > 0)
    {
        int nodeIdx = stack[--stackPtr];
        LinearBVHNode node = _BVHNodes[nodeIdx];
        
        // Check bounds distance
        float boundsDist = DistanceToBounds(vertex, node.boundsMin, node.boundsMax);
        if (boundsDist >= minDist)
        continue;
        
        if (node.triangleCount > 0)
        {
            // Leaf node - check triangles
            for (int i = 0; i < node.triangleCount; i++)
            {
                GPUTriangle tri = _Triangles[node.leftOrTriangleOffset + i];
                float3 cp = ClosestPointOnTriangle(vertex, tri.v0, tri.v1, tri.v2);
                float dist = length(vertex - cp);
                
                if (dist < minDist)
                {
                    minDist = dist;
                    closestPoint = cp;
                }
            }
        }
        else
        {
            // Internal node - push children
            int leftIdx = node.leftOrTriangleOffset;
            int rightIdx = -node.triangleCount; // Right child index
            if(rightIdx <= 0)
            {
                rightIdx = leftIdx + 1;
            }
            
            // Push farther node first (so closer is processed first)
            float leftDist = DistanceToBounds(vertex, _BVHNodes[leftIdx].boundsMin, _BVHNodes[leftIdx].boundsMax);
            float rightDist = DistanceToBounds(vertex, _BVHNodes[rightIdx].boundsMin, _BVHNodes[rightIdx].boundsMax);
            
            if (stackPtr < MAX_STACK_DEPTH - 1)
            {
                if (leftDist < rightDist)
                {
                    if (rightDist < minDist)
                    stack[stackPtr++] = rightIdx;
                    if (leftDist < minDist)
                    stack[stackPtr++] = leftIdx;
                }
                else
                {
                    if (leftDist < minDist)
                    stack[stackPtr++] = leftIdx;
                    if (rightDist < minDist)
                    stack[stackPtr++] = rightIdx;
                }
            }
        }
    }
    
    return minDist;
}

// Replace the DetermineSign function in SDFGenerator.compute with this:
float DetermineSign(float3 vertex, float3 closestPoint)
{
    // Cast rays in multiple directions and count intersections
    // Odd number of intersections = inside, even = outside
    
    float3 directions[3];
    directions[0] = float3(1, 0, 0);
    directions[1] = float3(0, 1, 0);
    directions[2] = float3(0, 0, 1);
    
    int insideVotes = 0;

    if (_BVHNodeCount == 0)
    return 1.0; // Outside if no geometry
    
    for (int d = 0; d < 3; d++)
    {
        float3 dir = directions[d];
        int intersectionCount = 0;
        
        // Stack-based BVH traversal for ray casting
        int stack[MAX_STACK_DEPTH];
        int stackPtr = 0;
        stack[stackPtr++] = 0;
        
        while (stackPtr > 0)
        {
            int nodeIdx = stack[--stackPtr];
            LinearBVHNode node = _BVHNodes[nodeIdx];
            
            // Ray-AABB intersection
            float3 invDir = 1.0 / dir;
            float3 t0 = (node.boundsMin - vertex) * invDir;
            float3 t1 = (node.boundsMax - vertex) * invDir;
            float3 tmin3 = min(t0, t1);
            float3 tmax3 = max(t0, t1);
            float tmin = max(max(tmin3.x, tmin3.y), tmin3.z);
            float tmax = min(min(tmax3.x, tmax3.y), tmax3.z);
            
            if (tmax < 0 || tmin > tmax)
            continue;
            
            if (node.triangleCount > 0)
            {
                // Leaf node - test triangles
                for (int i = 0; i < node.triangleCount; i++)
                {
                    GPUTriangle tri = _Triangles[node.leftOrTriangleOffset + i];
                    
                    // Möller–Trumbore ray-triangle intersection
                    float3 edge1 = tri.v1 - tri.v0;
                    float3 edge2 = tri.v2 - tri.v0;
                    float3 h = cross(dir, edge2);
                    float a = dot(edge1, h);
                    
                    if (abs(a) < 1e-8)
                    continue;
                    
                    float f = 1.0 / a;
                    float3 s = vertex - tri.v0;
                    float u = f * dot(s, h);
                    
                    if (u < 0.0 || u > 1.0)
                    continue;
                    
                    float3 q = cross(s, edge1);
                    float v = f * dot(dir, q);
                    
                    if (v < 0.0 || u + v > 1.0)
                    continue;
                    
                    float t = f * dot(edge2, q);
                    
                    if (t > 1e-6) // Ray intersection
                    {
                        intersectionCount++;
                    }
                }
            }
            else
            {
                // Internal node - push children
                int leftIdx = node.leftOrTriangleOffset;
                int rightIdx = -node.triangleCount; // Right child index
                if(rightIdx <= 0)
                {
                    rightIdx = leftIdx + 1;
                }
                if (stackPtr < MAX_STACK_DEPTH - 1)
                {
                    stack[stackPtr++] = leftIdx;
                    stack[stackPtr++] = rightIdx;
                }
            }
        }
        
        if (intersectionCount % 2 == 1)
        insideVotes++;
    }
    
    // Majority vote: 2 or more rays say inside = inside
    return (insideVotes >= 2) ? -1.0 : 1.0;
}

[numthreads(8, 8, 8)]
void InitializeSDF(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_VolumeResolution.x ||
    id.y >= (uint)_VolumeResolution.y ||
    id.z >= (uint)_VolumeResolution.z)
    return;
    
    _SDFVolume[id] = _InitialValue;
}

[numthreads(8, 8, 8)]
void MeshToSDF(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_VolumeResolution.x ||
    id.y >= (uint)_VolumeResolution.y ||
    id.z >= (uint)_VolumeResolution.z)
    return;
    
    float3 worldPos = VoxelToWorld(int3(id));
    float3 closestPoint;
    float distance = QueryBVH(worldPos, closestPoint);
    
    // Apply narrow band optimization - only compute accurate SDF near surface
    if (distance > _NarrowBandWidth)
    {
        _SDFVolume[id] = _NarrowBandWidth;
        return;
    }
    
    // Determine sign (inside = negative, outside = positive)
    // For closed meshes, we need proper inside/outside detection
    float sign = DetermineSign(worldPos, closestPoint);
    
    _SDFVolume[id] = distance * sign;
}

[numthreads(8, 8, 8)]
void FinalizeSDF(uint3 id : SV_DispatchThreadID)
{
    // Post-processing kernel for smoothing or fixing SDF issues
    if (id.x >= (uint)_VolumeResolution.x ||
    id.y >= (uint)_VolumeResolution.y ||
    id.z >= (uint)_VolumeResolution.z)
    return;
    
    // Currently a pass-through, can add Gaussian smoothing if needed
}