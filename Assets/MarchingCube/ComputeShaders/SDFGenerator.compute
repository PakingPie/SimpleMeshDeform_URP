// SDFGenerator.compute
#pragma kernel InitializeSDF
#pragma kernel MeshToSDF
#pragma kernel FinalizeSDF

// Output SDF volume
RWTexture3D<float> _SDFVolume;

// Input mesh data (from LinearBVH)
struct LinearBVHNode
{
    float3 boundsMin;
    int leftOrTriangleOffset;
    float3 boundsMax;
    int rightChildOrCount;  // Positive = leaf triangle count, Negative = -rightChildIndex
};

struct GPUTriangle
{
    float3 v0;
    float pad0;
    float3 v1;
    float pad1;
    float3 v2;
    float pad2;
};

StructuredBuffer<LinearBVHNode> _BVHNodes;
StructuredBuffer<GPUTriangle> _Triangles;

// Parameters
float3 _VolumeMin;
float3 _VolumeMax;
int3 _VolumeResolution;
int _BVHNodeCount;
float _InitialValue;
float _NarrowBandWidth;

// --- NEW: Chunked dispatch Z offset (in voxels) ---
int _ZSliceOffset;

// --- NEW: Mesh AABB for early-out (set from BVH root bounds) ---
float3 _MeshBoundsMin;
float3 _MeshBoundsMax;

// Stack for BVH traversal
#define MAX_STACK_DEPTH 64

float3 VoxelToWorld(int3 voxel)
{
    float3 t = (float3(voxel) + 0.5) / float3(_VolumeResolution);
    return lerp(_VolumeMin, _VolumeMax, t);
}

float PointToTriangleDistanceSq(float3 p, float3 a, float3 b, float3 c)
{
    float3 ab = b - a;
    float3 ac = c - a;
    float3 ap = p - a;
    
    float d1 = dot(ab, ap);
    float d2 = dot(ac, ap);
    if (d1 <= 0.0 && d2 <= 0.0)
        return dot(ap, ap);
    
    float3 bp = p - b;
    float d3 = dot(ab, bp);
    float d4 = dot(ac, bp);
    if (d3 >= 0.0 && d4 <= d3)
        return dot(bp, bp);
    
    float vc = d1 * d4 - d3 * d2;
    if (vc <= 0.0 && d1 >= 0.0 && d3 <= 0.0)
    {
        float v = d1 / (d1 - d3);
        float3 closest = a + v * ab;
        float3 diff = p - closest;
        return dot(diff, diff);
    }
    
    float3 cp = p - c;
    float d5 = dot(ab, cp);
    float d6 = dot(ac, cp);
    if (d6 >= 0.0 && d5 <= d6)
        return dot(cp, cp);
    
    float vb = d5 * d2 - d1 * d6;
    if (vb <= 0.0 && d2 >= 0.0 && d6 <= 0.0)
    {
        float w = d2 / (d2 - d6);
        float3 closest = a + w * ac;
        float3 diff = p - closest;
        return dot(diff, diff);
    }
    
    float va = d3 * d6 - d5 * d4;
    if (va <= 0.0 && (d4 - d3) >= 0.0 && (d5 - d6) >= 0.0)
    {
        float w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
        float3 closest = b + w * (c - b);
        float3 diff = p - closest;
        return dot(diff, diff);
    }
    
    float denom = 1.0 / (va + vb + vc);
    float v2 = vb * denom;
    float w2 = vc * denom;
    float3 closest = a + ab * v2 + ac * w2;
    float3 diff = p - closest;
    return dot(diff, diff);
}

float3 ClosestPointOnTriangle(float3 p, float3 a, float3 b, float3 c)
{
    float3 ab = b - a;
    float3 ac = c - a;
    float3 ap = p - a;
    
    float d1 = dot(ab, ap);
    float d2 = dot(ac, ap);
    if (d1 <= 0.0 && d2 <= 0.0)
        return a;
    
    float3 bp = p - b;
    float d3 = dot(ab, bp);
    float d4 = dot(ac, bp);
    if (d3 >= 0.0 && d4 <= d3)
        return b;
    
    float vc = d1 * d4 - d3 * d2;
    if (vc <= 0.0 && d1 >= 0.0 && d3 <= 0.0)
    {
        float v = d1 / (d1 - d3);
        return a + v * ab;
    }
    
    float3 cp = p - c;
    float d5 = dot(ab, cp);
    float d6 = dot(ac, cp);
    if (d6 >= 0.0 && d5 <= d6)
        return c;
    
    float vb = d5 * d2 - d1 * d6;
    if (vb <= 0.0 && d2 >= 0.0 && d6 <= 0.0)
    {
        float w = d2 / (d2 - d6);
        return a + w * ac;
    }
    
    float va = d3 * d6 - d5 * d4;
    if (va <= 0.0 && (d4 - d3) >= 0.0 && (d5 - d6) >= 0.0)
    {
        float w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
        return b + w * (c - b);
    }
    
    float denom = 1.0 / (va + vb + vc);
    float v2 = vb * denom;
    float w2 = vc * denom;
    return a + ab * v2 + ac * w2;
}

float DistanceToBoundsSq(float3 p, float3 boundsMin, float3 boundsMax)
{
    float3 closest = clamp(p, boundsMin, boundsMax);
    float3 diff = p - closest;
    return dot(diff, diff);
}

float QueryBVH(float3 vertex, out float3 closestPoint)
{
    float minDistSq = 1e20;
    closestPoint = vertex;
    
    if (_BVHNodeCount == 0)
        return sqrt(minDistSq);
    
    // Stack-based BVH traversal
    int stack[MAX_STACK_DEPTH];
    int stackPtr = 0;
    stack[stackPtr++] = 0; // Root node
    
    [loop]
    while (stackPtr > 0)
    {
        int nodeIdx = stack[--stackPtr];
        
        if (nodeIdx < 0 || nodeIdx >= _BVHNodeCount)
            continue;
            
        LinearBVHNode node = _BVHNodes[nodeIdx];
        
        // Check bounds distance (squared for efficiency)
        float boundsDistSq = DistanceToBoundsSq(vertex, node.boundsMin, node.boundsMax);
        if (boundsDistSq >= minDistSq)
            continue;
        
        if (node.rightChildOrCount > 0)
        {
            // Leaf node - check triangles
            int triCount = node.rightChildOrCount;
            int triOffset = node.leftOrTriangleOffset;
            
            for (int i = 0; i < triCount; i++)
            {
                GPUTriangle tri = _Triangles[triOffset + i];
                float3 cp = ClosestPointOnTriangle(vertex, tri.v0, tri.v1, tri.v2);
                float3 diff = vertex - cp;
                float distSq = dot(diff, diff);
                
                if (distSq < minDistSq)
                {
                    minDistSq = distSq;
                    closestPoint = cp;
                }
            }
        }
        else
        {
            // Internal node - push children
            int leftIdx = node.leftOrTriangleOffset;
            int rightIdx = -node.rightChildOrCount;
            
            // Validate indices
            if (leftIdx < 0 || leftIdx >= _BVHNodeCount || rightIdx < 0 || rightIdx >= _BVHNodeCount)
                continue;
            
            // Push farther node first (so closer is processed first)
            float leftDistSq = DistanceToBoundsSq(vertex, _BVHNodes[leftIdx].boundsMin, _BVHNodes[leftIdx].boundsMax);
            float rightDistSq = DistanceToBoundsSq(vertex, _BVHNodes[rightIdx].boundsMin, _BVHNodes[rightIdx].boundsMax);
            
            if (stackPtr < MAX_STACK_DEPTH - 2)
            {
                if (leftDistSq < rightDistSq)
                {
                    if (rightDistSq < minDistSq)
                        stack[stackPtr++] = rightIdx;
                    if (leftDistSq < minDistSq)
                        stack[stackPtr++] = leftIdx;
                }
                else
                {
                    if (leftDistSq < minDistSq)
                        stack[stackPtr++] = leftIdx;
                    if (rightDistSq < minDistSq)
                        stack[stackPtr++] = rightIdx;
                }
            }
        }
    }
    
    return sqrt(minDistSq);
}

// Determine if vertex is inside or outside the mesh using ray casting
float DetermineSign(float3 vertex, float3 closestPoint)
{
    if (_BVHNodeCount == 0)
        return 1.0;
    
    // Cast rays in 3 axis directions and vote
    float3 directions[3];
    directions[0] = float3(1, 0, 0);
    directions[1] = float3(0, 1, 0);
    directions[2] = float3(0, 0, 1);
    
    int insideVotes = 0;
    
    [unroll]
    for (int d = 0; d < 3; d++)
    {
        float3 dir = directions[d];
        int intersectionCount = 0;
        
        // Stack-based BVH traversal for ray casting
        int stack[MAX_STACK_DEPTH];
        int stackPtr = 0;
        stack[stackPtr++] = 0;
        
        [loop]
        while (stackPtr > 0)
        {
            int nodeIdx = stack[--stackPtr];
            
            if (nodeIdx < 0 || nodeIdx >= _BVHNodeCount)
                continue;
                
            LinearBVHNode node = _BVHNodes[nodeIdx];
            
            // Ray-AABB intersection
            float3 invDir = 1.0 / (dir + float3(1e-10, 1e-10, 1e-10));
            float3 t0 = (node.boundsMin - vertex) * invDir;
            float3 t1 = (node.boundsMax - vertex) * invDir;
            float3 tmin3 = min(t0, t1);
            float3 tmax3 = max(t0, t1);
            float tmin = max(max(tmin3.x, tmin3.y), tmin3.z);
            float tmax = min(min(tmax3.x, tmax3.y), tmax3.z);
            
            if (tmax < 0 || tmin > tmax)
                continue;
            
            if (node.rightChildOrCount > 0)
            {
                // Leaf node - test triangles
                int triCount = node.rightChildOrCount;
                int triOffset = node.leftOrTriangleOffset;
                
                for (int i = 0; i < triCount; i++)
                {
                    GPUTriangle tri = _Triangles[triOffset + i];
                    
                    float3 edge1 = tri.v1 - tri.v0;
                    float3 edge2 = tri.v2 - tri.v0;
                    float3 h = cross(dir, edge2);
                    float a = dot(edge1, h);
                    
                    if (abs(a) < 1e-8)
                        continue;
                    
                    float f = 1.0 / a;
                    float3 s = vertex - tri.v0;
                    float u = f * dot(s, h);
                    
                    if (u < 0.0 || u > 1.0)
                        continue;
                    
                    float3 q = cross(s, edge1);
                    float v = f * dot(dir, q);
                    
                    if (v < 0.0 || u + v > 1.0)
                        continue;
                    
                    float t = f * dot(edge2, q);
                    
                    if (t > 1e-6)
                    {
                        intersectionCount++;
                    }
                }
            }
            else
            {
                // Internal node - push children
                int leftIdx = node.leftOrTriangleOffset;
                int rightIdx = -node.rightChildOrCount;
                
                if (leftIdx >= 0 && leftIdx < _BVHNodeCount && rightIdx >= 0 && rightIdx < _BVHNodeCount)
                {
                    if (stackPtr < MAX_STACK_DEPTH - 2)
                    {
                        stack[stackPtr++] = leftIdx;
                        stack[stackPtr++] = rightIdx;
                    }
                }
            }
        }
        
        if ((intersectionCount & 1) == 1)
            insideVotes++;
    }
    
    // Majority vote
    return (insideVotes >= 2) ? -1.0 : 1.0;
}

[numthreads(8, 8, 8)]
void InitializeSDF(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_VolumeResolution.x ||
        id.y >= (uint)_VolumeResolution.y ||
        id.z >= (uint)_VolumeResolution.z)
        return;
    
    _SDFVolume[id] = _InitialValue;
}

[numthreads(8, 8, 8)]
void MeshToSDF(uint3 id : SV_DispatchThreadID)
{
    // --- CHANGED: apply Z offset for chunked dispatch ---
    uint3 globalId = uint3(id.x, id.y, id.z + (uint)_ZSliceOffset);

    if (globalId.x >= (uint)_VolumeResolution.x ||
        globalId.y >= (uint)_VolumeResolution.y ||
        globalId.z >= (uint)_VolumeResolution.z)
        return;
    
    float3 worldPos = VoxelToWorld(int3(globalId));

    // --- NEW: AABB early-out â€” skip voxels far from the mesh bounding box ---
    float aabbDistSq = DistanceToBoundsSq(worldPos, _MeshBoundsMin, _MeshBoundsMax);
    if (aabbDistSq > _NarrowBandWidth * _NarrowBandWidth)
    {
        _SDFVolume[globalId] = _NarrowBandWidth;
        return;
    }

    float3 closestPoint;
    float distance = QueryBVH(worldPos, closestPoint);
    
    // Apply narrow band optimization
    if (distance > _NarrowBandWidth)
    {
        _SDFVolume[globalId] = _NarrowBandWidth;
        return;
    }
    
    // Determine sign (inside = negative, outside = positive)
    float sign = DetermineSign(worldPos, closestPoint);
    
    _SDFVolume[globalId] = distance * sign;
}

[numthreads(8, 8, 8)]
void FinalizeSDF(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_VolumeResolution.x ||
        id.y >= (uint)_VolumeResolution.y ||
        id.z >= (uint)_VolumeResolution.z)
        return;
    
    // Pass-through for now - can add smoothing later
}