// DrillingComputeShader.compute
// GPU-accelerated cylindrical drilling for mesh processing

#pragma kernel CSMain

// Buffers
RWStructuredBuffer<float4> vertices;
RWStructuredBuffer<float4> results;

// Vertex count
int vertexCount;

// Drill parameters
float drillRadius;
float drillLength;

// Drill base position and direction (world space)
float3 drillBasePos;
float3 drillDirection;

// Drill mode: 0 = PushAlongAxis, 1 = PushRadially, 2 = InstantProject
int drillMode;

// Push speeds
float pushSpeed;
float radialSmoothingSpeed;
float surfaceMargin;

// Bounds clamping
float3 boundsMin;
float3 boundsMax;
int enforceBounds;

#define THREAD_GROUP_SIZE 256
#define EPSILON 0.0001

#define MODE_PUSH_ALONG_AXIS 0
#define MODE_PUSH_RADIALLY 1
#define MODE_INSTANT_PROJECT 2

// Clamp position to bounds
float3 ClampToBounds(float3 pos)
{
    return clamp(pos, boundsMin, boundsMax);
}

// Get an arbitrary perpendicular vector
float3 GetArbitraryPerpendicular(float3 dir)
{
    float3 perp = cross(dir, float3(0, 1, 0));
    if (dot(perp, perp) < 0.001)
    {
        perp = cross(dir, float3(1, 0, 0));
    }
    return normalize(perp);
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    
    if (index >= (uint)vertexCount)
        return;
    
    float4 vertex = vertices[index];
    float3 worldPos = vertex.xyz;
    float affected = 0.0;
    
    // Vector from drill base to the point
    float3 toPoint = worldPos - drillBasePos;
    
    // Project onto drill axis to get height along cylinder
    float height = dot(toPoint, drillDirection);
    
    // Check if within drill length
    if (height >= 0.0 && height <= drillLength)
    {
        // Get the radial vector (perpendicular to drill axis)
        float3 axialComponent = drillDirection * height;
        float3 radialVector = toPoint - axialComponent;
        float radialDistSqr = dot(radialVector, radialVector);
        
        // Use detection radius (slightly smaller than actual radius)
        float detectionRadius = drillRadius - surfaceMargin;
        float detectionRadiusSqr = detectionRadius * detectionRadius;
        
        if (radialDistSqr < detectionRadiusSqr)
        {
            // Point is inside cylinder
            float radialDist = sqrt(radialDistSqr);
            float3 projectedPoint = worldPos;
            
            // Push direction is opposite to drill direction
            float3 pushDirection = -drillDirection;
            
            if (drillMode == MODE_PUSH_ALONG_AXIS)
            {
                // Main push along axis (out of the hole)
                float normalizedHeight = height / drillLength;
                float axialPushStrength = pushSpeed * (0.5 + normalizedHeight * 0.5);
                projectedPoint += pushDirection * axialPushStrength;
                
                // Optional radial smoothing near edges
                if (radialSmoothingSpeed > 0.0 && radialDist > EPSILON)
                {
                    float edgeProximity = radialDist / drillRadius;
                    if (edgeProximity > 0.7)
                    {
                        float3 radialDirection = radialVector / radialDist;
                        float radialPush = radialSmoothingSpeed * (edgeProximity - 0.7) / 0.3;
                        projectedPoint += radialDirection * radialPush;
                    }
                }
            }
            else if (drillMode == MODE_PUSH_RADIALLY)
            {
                // Push radially outward
                float penetrationDepth = drillRadius - radialDist;
                float normalizedPenetration = penetrationDepth / drillRadius;
                
                if (radialDist < EPSILON)
                {
                    float3 perpendicular = GetArbitraryPerpendicular(drillDirection);
                    projectedPoint += perpendicular * pushSpeed;
                }
                else
                {
                    float3 radialDirection = radialVector / radialDist;
                    float radialPush = pushSpeed * (1.0 + normalizedPenetration);
                    projectedPoint += radialDirection * radialPush;
                }
            }
            else if (drillMode == MODE_INSTANT_PROJECT)
            {
                // Instant project to base plane
                projectedPoint = drillBasePos + radialVector;
            }
            
            worldPos = projectedPoint;
            
            // Apply bounds clamping if enabled
            if (enforceBounds > 0)
            {
                worldPos = ClampToBounds(worldPos);
            }
            
            affected = 1.0;
        }
    }
    
    results[index] = float4(worldPos, affected);
}